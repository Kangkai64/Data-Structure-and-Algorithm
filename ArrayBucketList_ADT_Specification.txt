ADT ArrayBucketList
An ArrayBucketList is a sophisticated hybrid data structure that combines the efficiency of hash-based storage with the flexibility of linked lists. It implements the DictionaryInterface and provides additional queue-like functionality for the Clinic Management System. The structure uses an array of linked lists (buckets) to handle hash collisions efficiently while maintaining fast access times. The architecture includes a bucket array for hash-based storage, a separate queue data structure, a custom hash function, and automatic load factor management with resizing capabilities.

Core Components:
1. Bucket Array: An array of linked lists for hash-based storage
2. Queue Data: A separate linked list for queue operations
3. Hash Function: Custom hash function for key distribution
4. Load Factor Management: Automatic resizing based on load factor threshold

Internal Classes:
LinkedList: Circular doubly-linked list implementation for buckets
Node: Individual node containing key-value pairs
BucketListIterator: Iterator for main bucket list
LinkedListIterator: Iterator for individual linked lists

Dictionary Interface Operations:

V add(K key, V value)
Description: Adds a new key-value pair to the bucket list or updates an existing key's value.
Algorithm: Validate key and value, calculate hash index using hashEntity(key, bucketCount), access appropriate bucket, search for existing key, update value if exists or add new node, check load factor and resize if necessary.
Precondition: key is not null and value is not null.
Postcondition: If key doesn't exist, new entry added to appropriate bucket. If key exists, existing value replaced. Load factor checked and buckets resized if threshold exceeded. Size counter updated appropriately.
Returns: null if new entry added, or previous value if existing key updated.
Time Complexity: O(1) average case, O(n) worst case when resizing.

V remove(K key)
Description: Removes a specific key-value pair from the bucket list.
Algorithm: Calculate hash index for the key, access appropriate bucket, search for key in bucket, remove node if found and decrement size.
Precondition: key is not null.
Postcondition: If key exists, node removed from bucket and size decremented. If key doesn't exist, no changes made.
Returns: Value associated with removed key, or null if key not found.
Time Complexity: O(1) average case, O(n) worst case.

V getValue(K key)
Description: Retrieves the value associated with a given key without removing it.
Algorithm: Calculate hash index for the key, access appropriate bucket, search for key in bucket, return associated value or null.
Precondition: key is not null.
Postcondition: No changes to the data structure.
Returns: Value associated with the key, or null if key not found.
Time Complexity: O(1) average case, O(n) worst case.

boolean contains(K key)
Description: Checks whether a specific key exists in the bucket list.
Algorithm: Calculate hash index for the key, access appropriate bucket, search for key in bucket, return true if found, false otherwise.
Precondition: key is not null.
Postcondition: No changes to the data structure.
Returns: true if key exists, or false if key not found.
Time Complexity: O(1) average case, O(n) worst case.

boolean isEmpty()
Description: Determines whether the bucket list contains any entries.
Algorithm: Return true if numberOfEntries equals 0.
Precondition: None.
Postcondition: No changes to the data structure.
Returns: true if no entries exist, or false if at least one entry exists.
Time Complexity: O(1).

boolean isFull()
Description: Determines whether the bucket list has reached capacity.
Algorithm: Return true if numberOfEntries equals bucketCount.
Precondition: None.
Postcondition: No changes to the data structure.
Returns: true if bucket list is at capacity, or false if more entries can be added.
Time Complexity: O(1).

int getSize()
Description: Returns the current number of entries in the bucket list.
Algorithm: Return numberOfEntries.
Precondition: None.
Postcondition: No changes to the data structure.
Returns: Number of entries as non-negative integer.
Time Complexity: O(1).

void clear()
Description: Removes all entries from the bucket list.
Algorithm: Clear all buckets (linked lists), reset numberOfEntries to 0.
Precondition: None.
Postcondition: All entries removed, size reset to 0, all buckets cleared.
Returns: void.
Time Complexity: O(n).

Queue Operations:

void addToQueue(K key, V value)
Description: Adds a key-value pair to the queue data structure.
Algorithm: Validate key and value, add to queueData linked list.
Precondition: key is not null and value is not null.
Postcondition: New entry added to queue, queue size increased by 1.
Returns: void.
Time Complexity: O(1).

V removeFront()
Description: Removes and returns the first element from the queue.
Algorithm: Check if queue is empty, if not empty remove head node and return its value, if empty return null.
Precondition: None.
Postcondition: If queue not empty, first element removed. If queue empty, no changes.
Returns: Value of first element, or null if queue is empty.
Time Complexity: O(1).

V peekFront()
Description: Returns the first element from the queue without removing it.
Algorithm: Check if queue is empty, return head node's value or null.
Precondition: None.
Postcondition: No changes to the queue.
Returns: Value of first element, or null if queue is empty.
Time Complexity: O(1).

Utility Operations:

double getLoadFactor()
Description: Calculates the current load factor of the bucket list.
Algorithm: Return (double) numberOfEntries divided by bucketCount.
Precondition: None.
Postcondition: No changes to the data structure.
Returns: Current load factor as double value.
Time Complexity: O(1).

String toString()
Description: Provides a string representation of the bucket list.
Algorithm: Build string with entry count and bucket count, iterate through all buckets, append each bucket's string representation.
Precondition: None.
Postcondition: No changes to the data structure.
Returns: String representation of the bucket list.
Time Complexity: O(n).

Internal Data Structures:

LinkedList Class:
Purpose: Circular doubly-linked list implementation for bucket storage.
Key Features: Circular structure with head.next pointing to head, doubly-linked nodes with previous and next pointers, maximum size limit of 16 nodes per bucket, efficient add/remove operations.
Operations: add(K key, V value) for adding new node to end, remove(K key) for removing node by key, getNodeByKey(K key) for finding node by key, clear() for removing all nodes, isEmpty() for checking if list is empty, toString() for string representation.

Node Class:
Purpose: Individual node containing key-value pair and navigation pointers.
Properties: key for the key value, value for the associated value, next for reference to next node, previous for reference to previous node.
Methods: Getters and setters for all properties, constructor for key-value initialization.

Performance Characteristics:
Time Complexity: Average case O(1) for most operations, worst case O(n) when hash collisions occur frequently, resizing O(n) when load factor threshold is exceeded.
Space Complexity: Storage O(n) where n is number of entries, minimal overhead due to efficient linked list implementation.
Load Factor Management: Threshold of 0.75 (75% capacity), doubles bucket count when threshold exceeded, all entries redistributed after resize.

Hash Function:
private int hashEntity(K key, int bucketCount) {
    return Math.abs(key.hashCode()) % bucketCount;
}
Characteristics: Uses Java's built-in hashCode() method, applies absolute value to handle negative hash codes, modulo operation ensures index within bucket range, provides good distribution for typical key types.

Iterator Implementation:

BucketListIterator:
Purpose: Iterates through all values in the bucket list.
Algorithm: Start with first bucket, find first non-empty bucket, iterate through bucket's linked list, move to next bucket when current bucket exhausted, continue until all buckets processed.
Methods: hasNext() for checking if more elements exist, next() for returning next value, findNextNode() for locating next non-empty bucket.

LinkedListIterator:
Purpose: Iterates through nodes in a single linked list.
Algorithm: Start with head node, track visited count to prevent infinite loops, return nodes sequentially, stop when all nodes visited.

Usage in Clinic Management System:

Primary Applications:
1. Patient Registry: Store patient records with patient ID as key
2. Doctor Directory: Map doctor IDs to doctor information
3. Medicine Inventory: Track medicine stock with medicine ID
4. Appointment Queue: Queue management for patient appointments
5. Treatment Records: Store patient treatment histories

Queue Functionality:
Patient Queuing: Manage walk-in patient queues
Appointment Scheduling: Queue-based appointment management
Medicine Dispensing: Queue for pharmacy operations

Design Patterns:
Implemented Patterns:
1. Hash Table Pattern: Efficient key-value storage
2. Linked List Pattern: Collision resolution
3. Iterator Pattern: Sequential access to elements
4. Factory Pattern: Node creation and management
5. Strategy Pattern: Hash function implementation

Benefits: Efficiency with O(1) average case operations, flexibility with dynamic resizing and queue operations, memory efficiency with minimal overhead per entry, type safety with generic implementation, extensibility for easy addition of new operations.

Error Handling:
Null Validation: All public methods validate null keys and values, returns null or throws exceptions as appropriate, prevents data corruption from null inputs.
Capacity Management: Automatic resizing prevents overflow, load factor monitoring maintains performance, graceful handling of maximum bucket sizes.

Related Classes:
DictionaryInterface: Contract implementation
HashUtility: Alternative hash functions
Entity Classes: Patient, Doctor, Medicine, etc.
Control Classes: Business logic that uses this ADT 